\chapter{The Database}
\section{Database Requirements}
The database in which LandFill stores card objects will need regular updating by the site owner, both with newly-printed MTG cards and to keep price data up to date. Each session, the database will be queried both when the user adds nonland cards, and when candidate land cards are identified for the deck based on the colours of these cards.

This creates two constraints for the database: it must be up-to-date but have reasonable response times over multiple queries for individual objects. An early prototype used the Scrython API (see \secref{sec:databasesource}) to fetch requested cards from an online database. While this guaranteed up-to-date information, it took more than ten minutes to retrieve a list of 50 nonland cards due to a combination of connection latency and the need to avoid overwhelming the server. The database must therefore store information locally, but be easily updatable. 

\section{Choice of Online Database~---~ScryFall/Scrython}
\label{sec:databasesource}
One popular source of MTG card data for developers is mtg.json, a json representation of all cards. Mtg.json is popular for the breadth of information it contains, including card reprints, making it useful for collection management software~\cite{mtgjson}. Since LandFill needs to know only the gameplay-relevant attributes of a card and its price, I favoured a more streamlined source. I ultimately chose the database Scryfall~\cite{scryfall}, which is predominantly used by players rather than programmers; I felt that this wider userbase would ensure up-to-date information. ScryFall offers an API for code integration, for which a Python library, Scrython~\cite{scrython} has already been developed. Scrython returns dict objects listing card attributes, referred to within LandFill's code and this writeup as ``SCOs'' (Scrython Card Objects). LandFill's database, therefore, is a translation of these SCOs to SQLAlchemy's ORM format. Allowing for small pauses to prevent server overuse, downloading all 30,000 cards (at time of writing) takes around one hour, and could easily be run weekly, or in response to new sets.

In addition to ease of access, ScryFall has the advantage of listing the colours produced by a given land card, eliminating the need to parse this from the card text. 

\section{Database Layout}
Instead of classic SQLAlchemy, the Database uses the slightly more feature-heavy Flask-SQLAlchemy extension~\cite{flasksqlalchemy}. This means that each mapped class extends Flask-SQLAlchemy's \texttt{model} ancestor class, rather than the \texttt{declarative-base} class used in classic SQLAlchemy. The relational mapping between models in mtg.db is shown in Fig.~\ref{fig:databaselayout}.

\myfig{mtg2.jpg}{Layout of mtg.db}{databaselayout}

The two upper rows of tables in Fig.~\ref{fig:databaselayout} map the many-to-many relationships which denote the availability of a card across formats and ``games'' (eg, physical MTG games, MTG: Arena). Focussing as I am on the Comander format, this is largely irrelevant, but remains in the schema for use in future development. Discussion henceforth will focus solely on the models Card, Cycle and Face. LandFill errs in favour of storing too much data, meaning that some card attributes, including \texttt{Card.\allowbreak\_silver\allowbreak\_bordered} and \texttt{Card.\allowbreak\_last\allowbreak\_printing}, are not relevant to this thesis. I will define attributes as they become relevant. 

\section{Database Management}
I developed a class, DatabaseManager, with methods that transfer card information from Scryfall to the Database via Scrython. Within my codebase, a single instance of DatabaseManager is created in one script, \texttt{manage\allowbreak\_database.py}. Running this will fully update the database with all existing cards. Pauses are built into the script using Python's \texttt{time} module to avoid overburdening ScryFall's servers. 

\section{Representing Multiple-Faced Cards}
Some cards have two faces, which behave like different cards with their own text and mana cost. Although most cards have only one face, I sought to keep the database in 1st Normal Form, a database normalization standard which stipulates that each column in a database contains only a single value per entry~\cite{databasenormalization}. I therefore treat Faces as having a many-to-one relationship with Cards. Broadly, the Face object has attributes used to determine its interaction with a given game state: i.e.,~its casting cost and potential basic landtypes (stored in the \texttt{faces.\allowbreak\_typeline} attribute), while the Card object holds attributes relating to the viability of a card within a deck and a given user's preferences (i.e.,~what colours of mana it produces, the card price).

\texttt{cards.\allowbreak\_layout} is one of several strings extracted from the SCO, each of which denotes a different way of formatting face playability (i.e.,~cards with the ``transform'' layout have one playable face; cards with the ``adventure'' and ``mdfc'' layout have two). The playability of a given face is stored in the \texttt{faces.\allowbreak\_playable} attribute.

Some cards are a spell card on one side and a land card on another. A card is considered a land if it has at least one playable face that is a land, represented by the \texttt{card.\allowbreak\_overall\allowbreak\_land} attribute. 

\section{Cycles}
Recall from Fig.~\ref{fig:cycles} land cards within the same cycle are mechanically identical but refer to different colours in their text. A card's membership in a given cycle is, unfortunately, not included in an SCO. Each Cycle object thus has a string attribute, \texttt{cycle.\allowbreak\_regex}. If DatabaseManager this to a card via regular expression, that card is connected to that cycle via Foreign Key. 


\section{Database Verification Testing}
A secondary script, \texttt{test\allowbreak\_db.py}, conducts both Unit Tests and Property Tests on the database. 

In Unit Testing, the output of code is compared to a pre-computed result~\cite{PropertyTesting}. \texttt{test\allowbreak\_db.py}'s unit tests check that there are an expected number of total cards and an expected number of total lands in each cycle. Unit testing cycles is important in ongoing maintenance, to ensure that any new regex patterns added for new cycles do not accidentally capture existing ones. 

In Property Testing, random inputs are generated for code, and outputs are checked to ensure they fall within broad parameters~\cite{PropertyTesting}. \texttt{test\allowbreak\_db.py}'s property tests randomly selects a sample of database entries and checks that none have more than two faces, and that none have two faces with the same text. This is more expedient than testing all cards, and allows reasonable confidence that the database is populated as expected.
