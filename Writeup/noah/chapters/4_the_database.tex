\chapter{The Database}
\section{Database Requirements}
The database in which LandFill stores card objects will need regular updating by the site owner, both with newly-printed MTG cards and to keep price data up to date. In a given session, the database will be queried at two points:

\begin{itemize}
\item When a user's decklist is added, to determine the mana costs of nonland cards.
\item To identify a list of candidate lands for the manabase.
\end{itemize}

This creates two constraints for the database: it must be up-to-date but have reasonable response times over multiple queries for individual objects. An early prototype used the Scrython API (see \secref{sec:databasesource}) to fetch requested cards from an existing online MTG database. While this guaranteed up-to-date information, it more than ten minutes to retrieve a list of 50 nonland cards due to a combination of connection latency and the need to avoid overwhelming the server. 

To accommodate both constraints, the database must store information locally, but be easily updatable. 

\section{Choice of Online Database~---~ScryFall/Scrython}
\label{sec:databasesource}
One popular source of MTG card data for developers is mtg.json, a json reprsentation of all cards. Mtg.json is popular for the breadth of information it contains, including card reprints, making it useful for development of shopfronts or collection management software~\cite{mtgjson}. Since LandFill needs to know only the gameplay-relevant attributes of a card and its price, I favoured a more streamlined source. I ultimately chose to use the database Scryfall~\cite{scryfall}, which is predomenantly used by players rather than programmers; I felt that this wider userbase would ensure up-to-date information. ScryFall offers an API for code integration, for which a python library, Scrython~\cite{scrython} has already been developed. Scrython returns dict objects listing card attributes, referred to within LandFill's code and this writeup as ``SCOs'' (Scrython Card Objects). LandFill's database, thererefore, is a translation of these SCOs to SQLAlchemy's ORM format. Allowing for small pauses to prevent server overuse, downloading all ~30,000 cards (at time of writing) takes around one hour, and could easily be run weekly, or in response to new sets.

In addition to ease of access ScryFall has the advantage of listing the colours produced by a given land card, eliminating the need to parse this from the card text. 

\section{Database Layout}
Since LandFill uses Flask, it is built not on SQLAlchemy but on the slightly more feature-heavy Flask-SQLAlchemy extension~\cite{flasksqlalchemy}. This means that each mapped class extends Flask-SQLAlchemy's \texttt{model} ancestor class, rather than the \texttt{declarative-base} class used in classic SQLAlchemy. The relational mapping between models in mtg.db is shown in Fig.~\ref{fig:databaselayout}.

\myfig{mtg2.jpg}{Layout of mtg.db}{databaselayout}

The two upper rows of tables in Fig.~\ref{fig:databaselayout} map the many-to-many relationships which denote the availability of a card across formats and ``games'' (eg, physical MTG games, MTG: Arena); one card is legal in many formats, and one format has many legal cards. Since the initial deployment of LandFill focusses on the Commander format, this is largely irrelevant, but remains in the schema for use in future expansion. Discussion henceforth will focus solely on the models Card (table: cards), Cycle (table: cycles) and Face (table: faces). 

Although not every attribute of a SCO is embodied in a model, in this initial development stage, LandFill errs in favour of storing too much data rather than too little, meaning that some card attributes, including \texttt{Card.\allowbreak\_silver\allowbreak\_bordered} and \texttt{Card.\allowbreak\_last\allowbreak\_printing}, are not relevant to this writeup. I will define attributes throughout this writeup as they become relevant. 

\section{Database Management}
I developed a class, DatabaseManager, which contains simple methods that bulk-transfer card information from Scryfall to the Database via Scrython. Within my codebase, a single instance of DatabaseManager is created in one script, \texttt{manage\allowbreak\_database.py}. Running this script will fully update the database with all existing cards. Pauses are built into the script using Python's \texttt{time} module to avoid overburdening ScryFall's servers. 

To facilitate debugging during development, ScryFall is never queried for all cards. Instead, a for-loop is used to systematically acquire cards in order of mana cost, and add them to the database only after all have been downloaded. This means that, when errors occurred during download, I can resume the download from midway through the loop rather than starting from the beginning.

\section{Representing Multiple-Faced Cards}
Some cards have two faces, each of which may be considered two different cards with their own text and mana cost. Although most cards have only one face, I sought to keep the database in 1st Normal Form, a database normalization standard which stipulates each column in a database contains only a single value per entry~\cite{databasenormalization}. I therefore treat Faces as having a many-to-one relationship with Cards. Broadly, the Face object has attributes used to determine its interaction with a given game state: i.e.,~its casting cost and potential basic landtypes (stored in the \texttt{faces.\allowbreak\_typeline} attribute), while the Card object holds attributes relating to the viability of a card within a deck and a given user's preferences (i.e.,~what colours of mana it produces, the card price).

\texttt{cards.\allowbreak\_layout} is one of several strings extracted from the SCO, each of which denotes a different way of formatting face playability (i.e.,~cards with the ``transform'' layout have one playable face; cards with the ``adventure'' and ``mdfc'' layout have two). The playabiltiy of a given face is stored in the \texttt{faces.\allowbreak\_playable} attribute.

Some cards are a spell card on one side and a land card on another. A card is considered a land if it has at least one playable face that is a land, represented by the \texttt{card.\allowbreak\_overall\allowbreak\_land} attribute. 

\section{Cycles}
Recall from Fig.~\ref{fig:cycles} land cards within the same cycle are mechanically identical but refer to different colours in their text. A card's memebership in a given cycle is, unfortunately, not included in a SCO. For this reason, each cycle has a string attribute, \texttt{cycle.\allowbreak\_regex}, consisting of a Regular Expression. If DatabaseManager matches the regex of a cycle to a card, that card is connected to that cycle via Foreign Key. Since some cycles are mechanically identical to each other but are distinguished by the presence of basic land types or whether the constituent cards have the ``snow'' card type, these are both also stored in the cycle object as Boolean values, to sort cards whose text matches multiple cycles.


\section{Database Verification Testing}
A secondary script, \texttt{test\allowbreak\_db.py}, conducts both Unit Tests and Property Tests on the database. 

In Unit Testing, the output of code is compared to a pre-computed result~\cite{PropertyTesting}. \texttt{test\allowbreak\_db.py}'s unit tests check that there are an expected number of total cards and an expected number of total lands in each cycle. Unit testing cycles is important in ongoing maintenance, to ensure that any new regex patterns added for new cycles do not accidentally capture existing ones. 

In Property Testing, random inputs are generated for code, and outputs are checked to ensure they fall within broad parameters~\cite{PropertyTesting}. \texttt{test\allowbreak\_db.py}'s property tests randomly selects a sample of database entries and checks that none have more than two faces, and that none have two faces with the same text. This is more expedient than testing all cards, and allows reasonable confidence that the database is populated as expected.
