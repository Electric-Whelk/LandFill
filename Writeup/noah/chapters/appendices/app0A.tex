%
% file: localoperator.tex
% author: Victor Brena
% description: Briefly describes properties of the local operator.
%

\chapter{Code Extracts}
\label{app:app01}

\lstset{
  basicstyle=\ttfamily\footnotesize, lineskip=-1pt,   % monospace + smaller
  lineskip=-1pt,                % reduce line spacing
  breaklines=true,              % wrap long lines
  tabsize=2,                    % tabs = 2 spaces
}

DeckBuilder Hill Climb process:

\begin{lstlisting}[language=Python]

class DeckBuilder(CardCollection):
    
    def hill_climb_stream(self):
        self.halt = False
        step_output = MonteCarlo(self.deck)
        step_output.hill_climb_test()
        self.last_worst = step_output.worst_performing_card.name
        yield f"Starting score: {step_output.game_proportions}"
        scores = [step_output.game_proportions]
        iterations = 0

        while not self.halt:
            iterations += 1
            step_output = self.hill_climb_increment(step_output)
            yield f"Replaced {self.last_worst} with {self.last_best} ({step_output.game_proportions})"
            props = step_output.game_proportions
            self.set_new_highscore(props)
            scores.append(props)
            self.halt = self.check_rolling_max(scores)

        self.deck.finalscore = step_output.game_proportions
        yield f"Final score: {self.deck.finalscore}"

     def hill_climb_increment(self, prior_test):
        worst_card = prior_test.worst_performing_card
        self.last_worst = worst_card.name
        prev_score = prior_test.game_proportions
        t = MonteCarlo(self.deck)
        if self.meets_minbasic_criteria(worst_card):
            cards_to_test = self.get_basic_spread()
        else:
            cards_to_test = self.get_cards_to_test()
        if isinstance(worst_card, BasicLand):
            cards_to_test = [x for x in cards_to_test if x.name != worst_card.name]
        self.deck.give(self, worst_card)

        champ = None
        tested_cards = []
        for trial_card in cards_to_test:
            self.give(self.deck, trial_card)
            trial_card.card_test_score = t.run_card_test(trial_card)
            self.deck.give(self, trial_card)
            if champ is None or trial_card.card_test_score > champ.card_test_score:
                champ = trial_card
            tested_cards.append(trial_card)

        tested_cards.sort(key=lambda x: x.card_test_score, reverse=True)
        tiebreaker_candidates = []
        for card in tested_cards:
            if card.card_test_score >= champ.card_test_score - 0.01:
                tiebreaker_candidates.append(card)
            else:
                break

        champ = self.break_tie(tiebreaker_candidates)
        self.last_best = champ.name

        if not self.halt:
            self.give(self.deck, champ)
            self.reset_scores(cards_to_test)
            t.hill_climb_test()
        return t

    def check_rolling_max(self, scores, window_size=3, improvement_threshold=0):
        if len(scores) < window_size *2:
            return False

        prior_window = scores[len(scores) - 2 * window_size: len(scores) - window_size]
        recent_window = scores[len(scores) - window_size:]
        best_recent = numpy.mean(recent_window)
        best_prior = numpy.mean(prior_window)
        improvement = best_recent - best_prior
        return improvement < improvement_threshold

\end{lstlisting}

Lump playability assessment:

\begin{lstlisting}[language=Python]
class Lump:
    def set_playability(self, lands, game, filter_subversion = False):
        if not filter_subversion:
            if self.cmc > len(lands):
                return False
            if len(lands) == 0 and self.cmc == 0:
                return True

        invalid = 9999
        mana_required = self.mana_as_list
        weighted = [[land.set_price(game, m) for m in mana_required] for land in lands]
        row, col = scipy.optimize.linear_sum_assignment(weighted)
        cost = sum([weighted[row[i]][col[i]] for i in range(len(lands))])
        self.mapping = {}
        output = cost < invalid

        if output:
            for i in range(len(lands)):
                self.mapping[lands[row[i]]] = mana_required[col[i]]
        if not output:
            if not filter_subversion:
                if game.battlefield.filterlands_present():
                    return self.account_for_filterlands(lands, game)
        return output

    def account_for_filterlands(self, lands, game):
        if not self.check_filterland_feasible(lands):
            return False

        divided = self.divide_filters(lands)
        normals = divided["normals"]
        filters = divided["filters"]
        for perm in permutations(filters):
            combinations = self.assign_filter_combinations_v2(perm, normals, game)
            for combination in combinations:
                self.filterloops += 1
                if self.set_playability(combination, game, filter_subversion = True):
                    return True
        return False

    def assign_filter_combinations_v2(self, filters, normals, game):

        def _recurse(filters_left, current_lands):
            if not filters_left:
                yield current_lands
                return

            current_filter = filters_left[0]
            remaining_filters = filters_left[1:]

            activated = False
            for i, land in enumerate(current_lands):
                if land.produces_at_least_one(current_filter.required, game):
                    new_lands = current_lands[:i] + current_lands[i + 1:] + current_filter.sublands
                    yield from _recurse(remaining_filters, new_lands)
                    activated = True

            if not activated:
                yield from _recurse(remaining_filters, current_lands + [current_filter])

        yield from _recurse(filters, normals)


\end{lstlisting}

MonteCarlo assessment of decks and specific cards:

\begin{lstlisting}
class MonteCarlo(Simulation):
    def run(self):
        self.deck.reset_card_score()
        self.run_tests()
        self.assess_deck_hc()
        self.assess_lands_hc()
    
    def run_tests(self, quit=True):
        for i in range(0, self._runs):
            g = Game(self.deck, turns=self.turns, verbose=self._close_examine)
            g.run(quit=quit)
            self.get_game_info(g)
    
    def assess_deck_hc(self):
        self.game_proportions = self.wasteless_games / self.runs
    
    def assess_lands_hc(self):
        for card in self.deck.lands_list():
            p = card.proportion_of_games()
        worst = None
        worst_score = 0
        after_sorting = sorted(self.deck.lands_list(), key=lambda x: x.proportions, reverse=False)

        for i in range(len(self.deck.lands_list())):
            rank = len(self.deck.lands_list()) - i

        candidates = self.get_worst_card_candidates(self.deck.card_list)
        for card in candidates:

            if isinstance(card, Land):
                if card.mandatory == True:
                    card.reset_grade()
                else:
                    if worst == None or card.proportions < worst_score:
                        worst = card
                        worst_score = card.proportions
                    #card.reset_grade()

        self.worst_performing_card = worst

    def run_card_test(self, card_in):
        self.deck.reset_card_score()
        card_in.options = []
        wasteless_turns = 0
        for _ in range(0, self.ct_runs):
            wasteless_turns += self.single_card_test(card_in)
        for card in self.deck.card_list:
            if isinstance(card, Land):
                card.reset_grade()
        return wasteless_turns / self.ct_runs

    def single_card_test(self, card_in):
        g = Game(self.deck, turns=self.turns)
        g.run(card_to_test=card_in)
        return self.wastelessness(g)

    def wastelessness(self, game) -> int:
        if game.leftover_mana == 0:
            return 1
        return 0
\end{lstlisting}

Determining Land and Lump to play each turn:

\begin{lstlisting}[language=Python]
  def play_land_and_spell(self):
        lands = self.lands_in_hand
        played_lands = self.battlefield.lands_list()

        for land in lands:
            self.hand.give(self.battlefield, land)
            land.tapped = not land.enters_untapped(self)
            played_lands.append(land)
            self.set_land_permit(land, played_lands)
            played_lands.remove(land)
            self.battlefield.give(self.hand, land)

        allows_largest = self.filter_by_largest(lands)
        filtered_as_taplands = self.filter_as_taplands(allows_largest)
        filtered_by_most_produced = self.filter_by_most_produced(filtered_as_taplands, library=False)
        to_play = filtered_by_most_produced[0]

        largest = to_play.largest_lump
        self.play_land_v2(to_play)
        largest.mapping = to_play.proposed_mapping
        self.play_lump_v2(to_play.largest_lump)

        for land in lands:
            land.reset_permits()

    def filter_by_largest(self, lands):
        biggest_enabled = max([l.largest_cmc for l in lands])
        return [l for l in lands if l.largest_cmc >= biggest_enabled]

    def filter_as_taplands(self, lands):
        taplands = [x for x in lands if not x.enters_untapped(self)]
        if len(taplands) > 0:
            return taplands
        else:
            return lands

    def filter_by_most_produced(self, lands, library=False):
        if len(lands) < 2:
            return lands
        if library == False:
            relevant_lands = self.battlefield.lands_list()
        else:
            relevant_lands = []
            relevant_lands.extend(self.battlefield.lands_list())
            relevant_lands.extend(self.hand.lands_list())

        available = self.get_available_pips(relevant_lands)
        needed = [x for x in self.master_lump.colorpips]
        absent = self.calculate_absence(needed, available)

        biggest_contributors = []
        for land in lands:
            land.contribution = len(self.calculate_absence(absent, land.live_prod(self)))
            if biggest_contributors == [] or land.contribution < biggest_contributors[0].contribution:
                biggest_contributors = [land]
            elif land.contribution == biggest_contributors[0].contribution:
                biggest_contributors.append(land)

        try:
            max_colors = max([len(x.live_prod(self)) for x in biggest_contributors])
        except ValueError:
            max_colors = 0
        return [x for x in biggest_contributors if len(x.live_prod(self)) >= max_colors]
\end{lstlisting}

Page 2 exclusion and inclusion handling for lands: 

\begin{lstlisting}
    function handlePlayerMoveCycleOutOfExclude(cycle) {
        const { blocked, messages } = checkCycleMoveExceptions(cycle);
        if (blocked) {
            showErrorMessages(messages);
            return;
        }
        removeCardsFromArray(cycle.cards, 'cycleMovedToExclude');
        removeCardsFromArray(cycle.cards, 'addedBecauseNotTappedButFetchable');
        removeCardsFromArray(cycle.cards, 'addedBecauseNotTappedAndNotFetchable');
        setFilters(prev => ({
            ...prev,
            addedBecauseNotTappedButFetchable: false,
            addedBecauseNotTappedAndNotFetchable: false
        }));
        moveCycleToPositiveByCardMembership(cycle);
    }

    function moveCycleToPositiveByCardMembership(cycle) {
        const firstCard = cycle.cards[0]; // all cards in a cycle should have the same positive array
        if (positiveArrays.include.some(c => c.name === firstCard.name)) {
            setColumns(prev => ({
                ...prev,
                include: [...prev.include, cycle].filter(uniqueByName),
                consider: prev.consider.filter(c => c.displayName !== cycle.displayName),
                exclude: prev.exclude.filter(c => c.displayName !== cycle.displayName)
            }));
        } else {
            setColumns(prev => ({
                ...prev,
                consider: [...prev.consider, cycle].filter(uniqueByName),
                include: prev.include.filter(c => c.displayName !== cycle.displayName),
                exclude: prev.exclude.filter(c => c.displayName !== cycle.displayName)
            }));
        }
    }

    useEffect(() => {
        if (!allowOffColorFetches) {
            cycles.forEach(cycle => {
                cycle.cards.forEach(card => {
                    if (card.offColorFetch) addCardToExcludeArray(card, "offColorFetch");
                });
            });
        } else {
            excludeArrays.offColorFetch.forEach(card =>
                removeCardFromExcludeArray(card, "offColorFetch")
            );
        }
    }, [allowOffColorFetches]);

    const onDragEnd = result => {
        if (!result.destination) return;
        const { source, destination } = result;
        if (source.droppableId === destination.droppableId) return;

        const srcList = Array.from(columns[source.droppableId]);
        const [movedCycle] = srcList.splice(source.index, 1);
        const destList = Array.from(columns[destination.droppableId]);
        destList.splice(destination.index, 0, movedCycle);

        setColumns(prev => ({
            ...prev,
            [source.droppableId]: srcList,
            [destination.droppableId]: destList
        }));

        if (destination.droppableId === "include") {
            moveCycleToPositive(movedCycle, "include");
            if (source.droppableId === "exclude") {handlePlayerMoveCycleOutOfExclude(movedCycle) }
        } else if (destination.droppableId === "consider") {
            moveCycleToPositive(movedCycle, "consider");
            if (source.droppableId === "exclude") {handlePlayerMoveCycleOutOfExclude(movedCycle) }
        } else if (destination.droppableId === "exclude") {
            movedCycle.cards.forEach(card =>
                addCardToExcludeArray(card, "cycleMovedToExclude")
            );
        }

    };

    UseEffect(() => {
        if (filters.maxPrice) {
            cycles.forEach(cycle => {
                cycle.cards.forEach(card => {
                    if (parseFloat(card[currency]) > parseFloat(filters.maxPrice)) {
                        addCardToExcludeArray(card, "belowMaxPrice");
                    } else {
                        removeCardFromExcludeArray(card, "belowMaxPrice");
                    }
                });
            });
        } else {
            excludeArrays.belowMaxPrice.forEach(card =>
                removeCardFromExcludeArray(card, "belowMaxPrice")
            );
        }
    }, [filters.maxPrice]);

    const handleSidePanelTick = (e, card) => {
        const isChecked = e.target.checked;
        if (!isChecked) {
            setExcludeArrays(prev => {
                if (prev.uncheckedByPlayer.some(c => c.name === card.name)) {
                    return prev;
                }
                return {
                    ...prev,
                    uncheckedByPlayer: [...prev.uncheckedByPlayer, card]
                };
            });
        } else {
            setExcludeArrays(prev => {
                const updated = {};
                for (const key in prev) {
                    updated[key] = prev[key].filter(c => c.name !== card.name);
                }
                return updated;
            });
        }
    };
\end{lstlisting}